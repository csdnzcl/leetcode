# 二分算法

## 一、基础概念与原理

### 1.1 算法定义
二分查找（Binary Search）是一种在**有序数组**中查找特定元素的搜索算法，通过反复将搜索区间对半分割来快速定位目标值。

**核心思想**：每次比较都将搜索空间减半，从 n → n/2 → n/4 → ... → 1

### 1.2 适用条件
- ✅ **数组必须有序**（升序或降序）
- ✅ **支持随机访问**（数组而非链表）
- ✅ **存在单调性**（可推广到更一般场景）

### 1.3 时间复杂度分析
- **时间复杂度**：O(log n)
- **空间复杂度**：O(1)（迭代版）/ O(log n)（递归版）

## 二、基础实现（Java）

**闭区间写法，即[left, right]**

```java
//1. 迭代版本（推荐）
    // 标准二分查找 - 返回目标索引，未找到返回-1
public static int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
        
    while (left <= right) {
        // 防止溢出
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;  // 找到目标
        } else if (arr[mid] < target) {
            left = mid + 1;  // 搜索右半部分
        } else {
            right = mid - 1;  // 搜索左半部分
        }
    }
        return -1;  // 未找到
}

//2. 递归版本
public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
    if (left > right) return -1;
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) 
        return binarySearchRecursive(arr, target, mid + 1, right);
    else 
        return binarySearchRecursive(arr, target, left, mid - 1);
}
```

## 三、经典变体与高级应用

### 3.1 查找第一个和最后一个位置
```java
// 查找目标值的第一个位置
public static int findFirst(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            right = mid - 1;  // 继续向左搜索
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

// 查找目标值的最后一个位置
public static int findLast(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            left = mid + 1;  // 继续向右搜索
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

### 3.2 Lower Bound 和 Upper Bound

```java
// Lower Bound: 返回第一个大于等于target的元素的索引
private int lowerBound(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
    
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        } else {
            left = mid + 1; // 范围缩小到 [mid+1, right]
        }
    }
    // 循环结束后 left = right+1
    // 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
    // 所以 left 就是第一个 >= target 的元素下标
    return left;
}

// Upper Bound: 返回第一个大于target的元素的索引
public static int upperBound(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### 3.3 旋转有序数组搜索
```java
public class RotatedArraySearch {
    // 在旋转有序数组中搜索 - 单次二分法
    public static int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) return mid;
            
            // 判断哪半边是有序的
            if (nums[left] <= nums[mid]) {  // 左半边有序
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;  // target在左半边
                } else {
                    left = mid + 1;   // target在右半边
                }
            } else {  // 右半边有序
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;   // target在右半边
                } else {
                    right = mid - 1;  // target在左半边
                }
            }
        }
        
        return -1;
    }
}
```

## 四、答案空间二分（Binary Search on Answer）

### 4.1 核心概念
当问题具有**单调性**时，可以将二分思想推广到**答案空间**：

- 最小化最大值问题
- 最大化最小值问题  
- 满足条件的最小/最大值

### 4.2 通用模板
```java
// 在答案空间 [minAns, maxAns] 中二分查找
public static int binarySearchOnAnswer(int minAns, int maxAns) {
    int left = minAns, right = maxAns;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (isValid(mid)) {  // 检查mid是否满足条件
            right = mid;     // 满足条件，尝试更小的值
        } else {
            left = mid + 1;  // 不满足条件，需要更大的值
        }
    }
    
    return left;  // 最终答案
}

// 辅助函数：检查当前值是否满足条件
private static boolean isValid(int mid) {
    // 根据具体问题实现验证逻辑
    return true;
}
```

### 4.3 经典例题：最小化最大工作量
```java
public class SplitArray {
    // 将数组分成m个子数组，使最大子数组和最小
    public static int splitArray(int[] nums, int m) {
        int left = 0, right = 0;
        
        // 确定搜索范围
        for (int num : nums) {
            left = Math.max(left, num);  // 最小可能值：单个元素的最大值
            right += num;                // 最大可能值：所有元素的和
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canSplit(nums, m, mid)) {
                right = mid;  // 可以分成m个子数组，尝试更小的最大和
            } else {
                left = mid + 1;  // 不能分成m个子数组，需要更大的最大和
            }
        }
        
        return left;
    }
    
    private static boolean canSplit(int[] nums, int m, int maxSum) {
        int count = 1;  // 子数组个数
        int currentSum = 0;
        
        for (int num : nums) {
            if (currentSum + num > maxSum) {
                count++;  // 需要新的子数组
                currentSum = num;
                
                if (count > m) return false;  // 子数组个数超过限制
            } else {
                currentSum += num;
            }
        }
        
        return true;
    }
}
```

## 五、实战练习题

### 基础题
1. **LeetCode 704**: 二分查找
2. **LeetCode 35**: 搜索插入位置
3. **LeetCode 34**: 在排序数组中查找元素的第一个和最后一个位置

### 进阶题
4. **LeetCode 33**: 搜索旋转排序数组
5. **LeetCode 81**: 搜索旋转排序数组 II（含重复元素）
6. **LeetCode 153**: 寻找旋转排序数组中的最小值

### 高阶题（答案空间二分）
7. **LeetCode 410**: 分割数组的最大值
8. **LeetCode 875**: 爱吃香蕉的珂珂
9. **LeetCode 1011**: 在D天内送达包裹的能力

## 六、常见陷阱与最佳实践

1. **优先使用迭代**：避免递归的栈溢出风险
2. **明确搜索空间**：在开始编码前确定left和right的初始值
3. **验证辅助函数**：对于答案空间二分，确保 `isValid()` 函数正确
4. **处理边界**：考虑数组为空、单个元素等特殊情况s