# 二叉树
## 二叉搜索树：
- 定义：对所有节点----左子树所有节点的值 < 根节点的值 < 右子树所有节点的值
- 性质：
-   中序遍历结果一定是**升序序列**。
-   查找、插入、删除操作在“平衡”情况下时间复杂度为 O(log n)，最坏退化成链时为 O(n) 
### 通过遍历验证二叉搜索树
1. 先序遍历：先判断，再递归
递归树中维护一个区间(left, right),该节点val必须属于该区间
```java
public boolean isBST(TreeNode root, long left, long right){
        if(root == null) {
            return true;
        }
        int x = root.val;
        return x > left && x < right
        && isBST(root.left, left, x)
        && isBST(root.right, x, right);
    }
```
2. 中序遍历：大于上一个节点---按照左子树， 根节点， 右子树的顺序依次遍历
```java
class Solution{
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) {
            return true;
        }
        if(!isValidBST(root.left)) {
            return false;
        }
        if(root.val <= pre) {
            return false;
        }
        pre = root.val;
        return isValidBST(root.right);
    }
}
```
3. 后序遍历：先递归再判断？？？？？？？？？？
```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root)[1] != Long.MAX_VALUE;
    }

    private long[] dfs(TreeNode node) {
        if (node == null) {
            return new long[]{Long.MAX_VALUE, Long.MIN_VALUE};
        }
        long[] left = dfs(node.left);
        long[] right = dfs(node.right);
        long x = node.val;
        // 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了
        if (x <= left[1] || x >= right[0]) {
            return new long[]{Long.MIN_VALUE, Long.MAX_VALUE};
        }
        return new long[]{Math.min(left[0], x), Math.max(right[1], x)};
    }
}
```
## 寻找公共祖先
### 普通二叉树
核心思路：后序遍历 (DFS)
我们需要使用**递归（深度优先搜索）**来从底向上查找。这个过程类似于“回溯”。
算法逻辑（三部曲）：

1. 终止条件（Base Case）：
- 如果当前节点 root 为空 或 等于 p 或 q，返回 root。
2. 递（Divide）：
- 递归在左子树中查找 p 或 q，结果记为 left。
- 递归在右子树中查找 p 或 q，结果记为 right。
3. 归（Conquer / Decision）：
- 情况 A： left 和 right 都不为空。说明 p 和 q 分别在当前节点的两侧。当前节点就是最近公共祖先。
- 情况 B： 只有 left 不为空。说明 p 和 q 都在左子树中，或者其中一个是另一个的祖先且都在左边。直接返回 left。
- 情况 C： 只有 right 不为空。同理，返回 right。
- 情况 D： 两个都为空。没找到，返回 null
### 二叉搜索树（BST）
利用 BST 的特性（左 < 根 < 右），我们不需要回溯，可以**从上往下**直接判断。

1. 核心思路
- 如果 p 和 q 的值都 小于 当前节点，说明 LCA 在 左子树，向左走。
- 如果 p 和 q 的值都 大于 当前节点，说明 LCA 在 右子树，向右走。
- 如果一个大一个小（或者其中一个等于当前节点），说明当前节点就是 分岔点，即 LCA。
## 二叉树的层序遍历（BFS）--广度优先搜索
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) {
            return new ArrayList<>();
        }
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> q = new ArrayDeque<>();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            List<Integer> vals = new ArrayList<>(n); // 预分配空间
            while (n-- > 0) {
                TreeNode node = q.poll();
                vals.add(node.val);
                if (node.left != null)  q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            ans.add(vals);
        }
        return ans;
    }
}
```
# 回溯
## 回溯入门：
1. 基本概念：什么是回溯？
- DFS + 状态重置：通过探索所有可能的分支来寻求问题的解。
2. **回溯三问**：
- 当前操作？枚举第i个数 选or不选
- 子问题？从下标 >= i的数字中构造子集
- 下一个子问题？ 从下标 >= i+1的数字中构造子集
```java
result = []
void backtrack(路径, 选择列表) {
    // 1. 结束条件：如果满足条件，把当前路径加入结果集
    if (满足结束条件) {
        result.add(路径);
        return;
    }
    // 2. 核心逻辑：遍历选择列表
    for (选择 in 选择列表) {
        // --- 做选择 ---
        if (如果不合法) continue; // 剪枝（可选）
        将该选择加入路径;

        // --- 进入下一层决策树 ---
        backtrack(路径, 新的选择列表);
        
        // --- 撤销选择（回溯的关键！）---
        将该选择从路径中移除;
    }
}
//示例：
void dfs(int i, List<String> ans, char[] path, char[] digits) {
        if(i == digits.length){
            ans.add(new String(path));
            return ;
        }
        String letter = MAPPING[digits[i] - '0'];
        for (char c : letter.toCharArray()) {
            path[i] = c;
            dfs(i+1, ans, path, digits);
        }
    }
```
3. 进阶：什么是剪枝？
- 在递归过程中，如果发现当前分支已经明显不可能得到正确答案，就直接continue或return ，不再往深处走
## 分类
### 子集型回溯：每个元素都可以选/不选
1. **选or不选**？---输入视角：
```java
private void dfs(int i, int[] nums, List<Integer> path, List<List<Integer>> ans) {
    if (i == nums.length) { // 子集构造完毕
        ans.add(new ArrayList<>(path)); // 复制 path
        return;
    }

    // 不选 nums[i]-----灵魂
    dfs(i + 1, nums, path, ans);

    // 选 nums[i]
    path.add(nums[i]);
    dfs(i + 1, nums, path, ans);
    path.removeLast(); //进行回溯
}
```
2. 枚举选哪个？---答案视角：
```java
private void dfs(int i, int[] nums, List<Integer> path, List<List<Integer>> ans) {
    ans.add(new ArrayList<>(path)); // 复制 path
    for (int j = i; j < nums.length; j++) { // 枚举选择的数字
        path.add(nums[j]);
        dfs(j + 1, nums, path, ans);
        path.removeLast(); // path.remove(path.size() - 1);
    }
}
```
3. 较难例题：力扣131.分割回文串：给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案
- 思路：对于串s: aab   a,a,b---转换为枚举逗号，选or不选
```java
class Solution {
    public List<List<String>> partition(String s) {
        char[] string = s.toCharArray();
        List<String> path = new ArrayList<>();
        List<List<String>> ans = new ArrayList<>();
        dfs(0, string, path, ans);
        return ans;
    }
    private void dfs(int i, char[] s, List<String> path, List<List<String>> ans) {
        if (i == s.length) { 
            ans.add(new ArrayList<>(path)); 
            return;
        }
        for(int j = i; j < s.length; ++j){
            if(!isPalindrome(s, i, j)){
                continue;
            }
            path.add(new String(s, i, j - i + 1));
            dfs(j + 1, s, path, ans);
            path.remove(path.size() - 1);
        }
    }
    private boolean isPalindrome(char[] str, int left, int right) {
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```
### 组合型回溯及剪枝
- 组合：注重选择的内容，而不在乎选择的顺序。
- 排列：在乎选择的顺序
例如：
- 排列：[1, 2] 和 [2, 1] 是两个**不同**的结果。
- 组合：[1, 2] 和 [2, 1] 被视为**相同**结果（因为元素一样），通常我们只保留 [1, 2]
1. 核心逻辑：startIndex---代码中的i
“不走回头路”： 每一层递归，只能从当前数字的后面开始选。
我们需要在递归函数中维护一个参数，通常叫 startIndex（即代码里的 i）。

全排列：每次都从头遍历（需要 visited 数组标记谁用过）。
组合：每次从 startIndex 开始遍历（不需要 visited 数组，因为前面的数字自动被排除在 startIndex 之前了）。

2. 标准模板：LeetCode 77. 组合
题目描述：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
比如 n=4, k=2，结果是 [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]。

未剪枝的基础版代码
```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(1, n, k, ans, path);
        return ans;
        
    }
    void dfs(int i, int n, int k, List<List<Integer>> ans, List<Integer> path){
        if(path.size() == k){
            ans.add(new ArrayList(path));
            return;
        }
        for(int j = i; j <= n; ++j) {
            path.add(j);
            dfs(j + 1, n, k, ans, path);
            path.remove(path.size() - 1);
        }
    }
}
```
3. 进阶：如何剪枝？----针对**逆向剪枝**---搜索树的剪枝
- 剪枝思路：如果剩下的数字已经不够凑齐 k 个了，就直接停止循环--剪掉**搜索树**的分支
- 剪枝公式：逆向剪枝---逆向
设path.size() = m
则还需要选 d = k - m 个数
设当前需要从[1,i]这i个数中选择
如果**i < d**
最后必然无法选出k个数，提前结束循环
**逆向剪枝**代码示例：
```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(n, k, path, ans); // 从 i=n 开始倒着枚举，这样 dfs 中就不需要 n 了，少传一个参数
        return ans;
    }

    private void dfs(int i, int k, List<Integer> path, List<List<Integer>> ans) {
        int d = k - path.size(); // 还要选 d 个数
        if (d == 0) { // 选好了
            ans.add(new ArrayList<>(path));
            return;
        }
        // 枚举的数不能太小，否则后面没有数可以选
        for (int j = i; j >= d; j--) {
            path.add(j);
            dfs(j - 1, k, path, ans);
            path.removeLast(); // path.remove(path.size() - 1);
        }
    }
}
```
正向剪枝公式: **i <= n - (k - path.size()) + 1**
```java
for(int j = i; j <= n - (k - path.size()) + 1; ++j) {
    path.add(j);
    dfs(j + 1, n, k, ans, path);
    path.remove(path.size() - 1);
}
```

### 排列型回溯
1. 全排列
```java
private void dfs(int i, int maxDepth, int[] nums, int[] visited, List<Integer> path, List<List<Integer>> ans){
    if(i == maxDepth) {
        ans.add(new ArrayList(path));
        return ;
    }
    for(int j = 0; j < maxDepth; ++j) {
        if(visited[j] == 0){
            visited[j] = 1;
            path.add(nums[j]);
            dfs(i+1, maxDepth, nums, visited, path, ans);
            visited[j] = 0;
            path.remove(path.size() - 1);
        }
    }
}
```
2. N皇后
- 问题简述：
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
- **核心思路**：
1. 解决不同行不同列问题：
- 用一个长为 n 的数组 col 记录皇后的位置  
- 即第 i 行的皇后在第 col[i] 列  
- 那么 col 必须是一个 0 到 n-1 的排列
2. 解决斜线问题：r:行号      l：列号
- 对右上方的皇后：r + c == C
- 对左上方的皇后：r - c == C1
- 更加直观点：对于同一斜线上的点(r1, c1), (r2, c2)满足：
```java
Math.abs(r1 - r2) == Math.abs(c1 - c2)
```
代码：
```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        // 使用一维数组记录每行皇后的位置，queens[r] = c
        //即坐标：(r, queens[r])
        int[] queens = new int[n]; 
        dfs(0, n, queens, ans);
        return ans;
    }

    private void dfs(int r, int n, int[] queens, List<List<String>> ans) {
        if (r == n) {
            List<String> board = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                char[] row = new char[n];
                Arrays.fill(row, '.');
                row[queens[i]] = 'Q';
                board.add(new String(row));
            }
            ans.add(board);
            return;
        }
        for (int c = 0; c < n; c++) {
            if (isValid(r, c, queens)) { 
                queens[r] = c; 
                dfs(r + 1, n, queens, ans);
                // 回溯：queens 是一维数组，下一次循环会直接覆盖 queens[r]
            }
        }
    }

    // --- 未优化的冲突检查函数 ---
    // 时间复杂度：O(r)，也就是 O(N)
    private boolean isValid(int r, int c, int[] queens) {
        // 只需要检查之前的行 (0 到 r-1)
        for (int i = 0; i < r; i++) {
            // 1. 检查列冲突：之前的皇后是否在同一列 c
            if (queens[i] == c) {
                return false;
            }
            // 2. 检查斜线冲突：
            if (Math.abs(r - i) == Math.abs(c - queens[i])) {
                return false;
            }
        }
        return true;
    }
}
```
3. N皇后优化技巧
- 把r + c记录到一个布尔数组diag1中，放皇后前判断：如果diag1[r+c] 为真，则无法放皇后
- 把r - c使用diag2记录，为了避免负数，需要加上 n - 1
优化结果：判断是否放皇后的时间复杂度从O(n) --->> O(1)。
```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        int[] queens = new int[n]; // 皇后放在 (r,queens[r])
        boolean[] col = new boolean[n]; //第col[i]列被占据
        boolean[] diag1 = new boolean[n * 2 - 1];
        boolean[] diag2 = new boolean[n * 2 - 1];
        dfs(0, queens, col, diag1, diag2, ans);
        return ans;
    }

    private void dfs(int r, int[] queens, boolean[] col, boolean[] diag1, boolean[] diag2, List<List<String>> ans) {
        int n = col.length;
        if (r == n) {
            List<String> board = new ArrayList<>(n); // 预分配空间
            for (int c : queens) {
                char[] row = new char[n];
                Arrays.fill(row, '.');
                row[c] = 'Q';
                board.add(new String(row));
            }
            ans.add(board);
            return;
        }
        // 在 (r,c) 放皇后
        for (int c = 0; c < n; c++) {
            int rc = r - c + n - 1;
            if (!col[c] && !diag1[r + c] && !diag2[rc]) { // 判断能否放皇后
                queens[r] = c; // 直接覆盖，无需恢复现场
                col[c] = diag1[r + c] = diag2[rc] = true; // 皇后占用了 c 列和两条斜线
                dfs(r + 1, queens, col, diag1, diag2, ans);
                col[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场
            }
        }
    }
}
```