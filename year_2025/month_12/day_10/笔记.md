# 动态规划
## 区间DP
### 1. 核心概念

**区间 DP** 主要用于解决在一个区间 $[i, j]$ 上进行操作的问题。
它的核心思想是：**大区间的解 = 小区间的解 + 合并/操作代价**（VS前面所学的线性DP）

#### 1.1 形象理解：套娃与合并
想象你在玩“合并石子”或者“消除气球”的游戏。想要知道消灭一排气球 $[1...10]$ 的最高得分，你可能需要先知道 $[1...5]$ 和 $[6...10]$ 的最高得分，然后再加上最后一步的操作分数。

#### 1.2 状态定义
通常定义二维数组 `dp[i][j]`：
* **含义：** 区间 **$[i, j]$** （从下标 $i$ 到下标 $j$ ）范围内的最优解（最大值/最小值/方案数）。
* **目标：** 我们最终想要的是 `dp[0][n-1]`（整个数组的最优解）。

---

### 2. 核心难点：遍历顺序

这是区间 DP 与线性 DP 最大的区别！
我们**不能**简单地用 `for i` 和 `for j` 从小到大遍历。
因为计算大区间 `dp[i][j]` 时，我们需要用到内部小区间（如 `dp[i+1][j-1]`）的值。

**正确的遍历顺序是：按区间长度 (`len`) 从小到大遍历。**

* 第一层循环：枚举区间长度 `len` (2, 3, ... n)
* 第二层循环：枚举左端点 `i`
* 第三层循环：枚举分割点 `k` (决策点)

#### 2.1 代码通用模板 (Java)

```java
// 1. 初始化 dp 数组（处理长度为 1 的基础情况）
for (int i = 0; i < n; i++) {
    dp[i][i] = ...; 
}

// 2. 第一层：枚举区间长度 len (通常从 2 开始，因为 1 已经初始化)
for (int len = 2; len <= n; len++) {
    // 3. 第二层：枚举左端点 i
    for (int i = 0; i <= n - len; i++) {
        // 计算右端点 j
        int j = i + len - 1;
        
        // 4. 第三层：枚举分割点 k (i <= k < j)
        // 将区间 [i, j] 切分成 [i, k] 和 [k+1, j]
        for (int k = i; k < j; k++) {
            dp[i][j] = Math.max(dp[i][j], 
                                dp[i][k] + dp[k+1][j] + cost(i, j));
        }
    }
}
```
### 3. 模型解析
#### 3.1 入门：石子合并
> **题目描述：**：有 $N$ 堆石子排成一排，每次只能合并相邻的两堆，合并的代价是两堆石子数量之和。求将所有石子合并成一堆的最小代价。
+ **状态定义**： dp[i][j] 表示合并第 $i$ 堆到第 $j$ 堆的最小代价。
+ **转移逻辑**： 想要合并 $[i, j]$，最后一步肯定是把“左边某一部分”和“右边某一部分”合成一大堆。
    + 左边部分：$[i, k]$，代价 dp[i][k]
    + 右边部分：$[k+1, j]$，代价 dp[k+1][j]
    + 最后一步合并代价：区间 $[i, j]$ 的元素和（用前缀和 sum[j+1] - sum[i] 快速计算）。
+ **状态转移方程**：$$dp[i][j] = \min_{i \le k < j} (dp[i][k] + dp[k+1][j]) + \text{sum}[i \dots j]$$
```java


```

---

#### 3.2 进阶：回文类问题--最长回文子序列 (LeetCode 516)
回文串天然具有“区间”属性（掐头去尾还是回文）。这类问题通常不需要枚举分割点 $k$，只需要比较区间两端 $i$ 和 $j$ 的字符。

> **题目描述：** 给你一个字符串 `s` ，找出其中最长的回文子序列的长度。

**思路分析：**
* **状态定义：** $dp[i][j]$ 表示字符串 `s` 在区间 $[i, j]$ 内的最长回文子序列长度。
* **转移逻辑：**
    1.  **若 `s[i] == s[j]`**：这俩字符天生一对，可以作为回文的外壳。长度 = 内部的最长回文 + 2。
        * $dp[i][j] = dp[i+1][j-1] + 2$
    2.  **若 `s[i] != s[j]`**：它俩不能同时配对。我们要么舍弃 $i$（看 $[i+1, j]$），要么舍弃 $j$（看 $[i, j-1]$），取最大的。
        * $dp[i][j] = \max(dp[i+1][j], \quad dp[i][j-1])$
* **注意：** 这里的“区间长度”遍历依然是核心。

**Java 代码实现：**
```java
//1. 记忆化搜索
//dfs(i, j):从s[i] 到 s[j] 的最长回文子序列的长度
int dfs(int i, int j, char[] str, int[][] memo){
    if(i == j) {
        return 1;
    }
    else if(i > j) {
        return 0;
    }
    else if (memo[i][j] != -1){
        return memo[i][j];
    }
    else if(str[i] == str[j]) {
        return memo[i][j] = 2 + dfs(i + 1, j - 1, str, memo);
    }
    else return memo[i][j] = Math.max(dfs(i + 1, j, str, memo), dfs(i, j - 1, str, memo));
}

//2. 区间DP

class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];

        // 1. 初始化：单个字符本身就是回文，长度为 1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        // 2. 枚举区间长度 len (从 2 开始)
        for (int len = 2; len <= n; len++) {
            // 3. 枚举左端点 i
            for (int i = 0; i <= n - len; i++) {
                // 计算右端点 j
                int j = i + len - 1;

                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
}
```

---

#### 3.3 高阶模型：戳气球 (LeetCode 312)

> **题目描述：** 有 $n$ 个气球，戳破第 $i$ 个气球，你可以获得 `nums[i-1] * nums[i] * nums[i+1]` 枚硬币。求能获得的最大硬币数量。

**思路分析：**
* **难点：** 如果正向思考“先戳谁”，戳破一个后，左右两边的气球会相邻，导致数组下标结构发生变化，无法确立稳定的状态。
* **破局：逆向思维。** 我们不思考“第一个戳谁”，而是思考**“最后一个被戳破的是谁？”**
    * 假设 $k$ 是区间 $(i, j)$ 里**最后一个**被戳破的气球。
    * 既然它是最后一个，那么在它被戳破的那一刻，**它的左边一定是 $i$，右边一定是 $j$**（因为 $(i, k)$ 和 $(k, j)$ 之间的气球早就全被戳爆了）。
* **状态定义：** $dp[i][j]$ 表示戳破**开区间** $(i, j)$ 之间所有气球能得的最大分。（注意：$i$ 和 $j$ 是边界，**不戳**，只作为倍数乘进去）。
* **转移方程：**
    $$dp[i][j] = \max_{i < k < j} \{ dp[i][k] + dp[k][j] + val[i] \times val[k] \times val[j] \}$$
    * $dp[i][k]$: 左半边的最大得分
    * $dp[k][j]$: 右半边的最大得分
    * $val[i] \times val[k] \times val[j]$: 最后戳爆 $k$ 时拿到的分

**Java 代码实现：**
```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        // 1. 预处理：创建一个新数组，首尾添加 1，方便处理边界
        int[] val = new int[n + 2];
        val[0] = 1;
        val[n + 1] = 1;
        for (int i = 0; i < n; i++) val[i + 1] = nums[i];

        // dp[i][j] 表示开区间 (i, j) 的最大金币
        // 新数组长度为 n+2，下标范围 0 到 n+1
        int[][] dp = new int[n + 2][n + 2];

        // 2. 枚举区间长度 len
        // 这里的 len 指的是开区间 (i, j) 的跨度 j - i
        // 跨度至少为 2，中间才可能有气球 k (比如 0...2 中间有 1)
        for (int len = 2; len <= n + 1; len++) {
            // 3. 枚举左端点 i
            for (int i = 0; i <= n + 1 - len; i++) {
                int j = i + len; // 右端点
                
                // 4. 枚举分割点 k (即最后一个被戳破的气球)
                // k 必须在开区间 (i, j) 内部，所以 i < k < j
                for (int k = i + 1; k < j; k++) {
                    int sum = val[i] * val[k] * val[j]; // 最后一次得分
                    sum += dp[i][k] + dp[k][j];         // 加上左右子问题的最优解
                    dp[i][j] = Math.max(dp[i][j], sum);
                }
            }
        }
        // 目标：戳破 (0, n+1) 之间的所有气球，即原数组的所有气球
        return dp[0][n + 1];
    }
}
```
---

### 4. 必刷题目清单

| 题目 | 难度 | 考察点 | 备注 |
| :--- | :--- | :--- | :--- |
| **1. 最长回文子序列 (LC 516)** | Medium | 区间 DP 基础 | **入门必做**，熟悉 len 和 i 的循环结构，不需要枚举 k |
| **2. 预测赢家 (LC 486)** | Medium | 博弈论 + 区间 DP | 理解“我取最大，对手逼我取最小” ($dp[i][j] = \max(nums[i]-dp[i+1][j], \dots)$) |
| **3. 多边形三角剖分的最低得分 (LC 1039)** | Medium | 类似石子合并 | 其实就是环形的石子合并，逻辑一样，几何包装 |
| **4. 戳气球 (LC 312)** | Hard | 逆向思维 + 开区间 | 面试高频 Hard 题，核心在于定义“最后一步” |
| **5. 切棍子的最小成本 (LC 1547)** | Hard | 坐标映射 + 区间 DP | 戳气球的变种，注意切点的坐标处理 |

题目3：多边形三角剖分的最低得分(lc 1039)
```java
//1. 记忆化搜索
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        int[][] memo = new int[n][n];
        for(int[] mat : memo) {
            Arrays.fill(mat, -1);
        }
        return dfs(0, n - 1, values, memo);
    }

    //dfs(i, j)：从i到j的最多得分
    int dfs(int i, int j, int[] values, int[][] memo) {
        int n = j - i;
        if(n == 1) return 0;
        if(memo[i][j] != -1) return memo[i][j];
        int min = Integer.MAX_VALUE / 2;
        for(int k = i + 1; k < j; ++k) {
            int sum = dfs(i, k, values, memo) + dfs(k, j, values, memo) + values[i] * values[j] * values[k];
            min = Math.min(min, sum);
        }
        return memo[i][j] = min;
    }
}

//2. 递推：
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        int[][] dp = new int[n + 1][n + 1];
        for(int i = n - 1; i >= 0; --i) {
            for(int j = 0; j < n; ++j){
                int num = j - i;
                if(num <= 1)
                    dp[i][j] = 0;
                else{
                    int min = Integer.MAX_VALUE / 2;
                    for(int k = i + 1; k < j; ++k) {
                        int sum = values[i] * values[k] * values[j] + dp[i][k] + dp[k][j];
                        min = Math.min(sum, min);
                    }
                    dp[i][j] = min;
                }
            }
        }
        return dp[0][n - 1];
        
    }
}
```
---

### 5. 总结：区间 DP 的“三板斧”

遇到“数组区间操作”、“合并”、“分割”类问题，只要数据规模 $N \approx 500$ 左右，直接套用以下套路：

1.  **画表：** 脑补一个二维表格，知道我们要填的是右上角那一半。
2.  **定序（最重要）：** * 第一层循环：**长度 `len`** (从小到大)
    * 第二层循环：**左端点 `i`**
    * 第三层循环：**分割点 `k`** (决策点)
3.  **方程：** 大区间 = 左半边 + 右半边 + 合并代价。