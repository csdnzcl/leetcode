# 动态规划
## 树形DP
### 树的直径
概念：树中任意两个节点之间最长路径的长度
补充：树的节点数 = 总边数 + 1
#### 二叉树
**二叉树的直径**：从一个叶子出发并向上，在某个节点**拐弯**，向下到达另一个叶子----得到由两条**链**拼起来的路径（也可能只有一条链）
**算法**：
+ 遍历二叉树，在计算最长链的同时，顺带计算直径
    + 在当前节点**拐弯**的直径长度 = 左子树最长链 + 右子树最长链 + 2.
    + 返回给父节点的是以**当前节点为根的子树的最长链**：max(左子树max, 右子树max) + 1;

1. **例题一**：力扣543.二叉树的直径
**题目描述**：给你一棵二叉树的根节点，返回该树的 直径 。二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。两节点之间路径的 长度 由它们之间边数表示。
```java
class Solution {
    int max = -1;
    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return max;
    }

    int dfs(TreeNode root) {
        if(root == null) return -1;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int cur = left + right + 2;
        max = Math.max(max, cur);
        return Math.max(left, right) + 1;
    }
}
```
2. **例题二**：力扣124.二叉树中的最大路径和
**题目描述**：二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和。
```java
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        max = root.val;
        dfs(root);
        return max;
    }

    int dfs(TreeNode root) {
        if(root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int cur = left + right + root.val;
        max = Math.max(cur, max);
        return Math.max(0, Math.max(left, right) + root.val);
    }
}
```
#### 一般树
邻居：相连的节点
**如何求树的直径？**
+ 思路一：遍历x的子树，把子树最长链的长度都存到一个列表中，排序，取最大的两个

+ 思路二：遍历x的子树的同时求最长 + 次长
链式前向心？？？？

**例题**：力扣2246.相邻字符不同的最长路径
**题目描述**：
给你一棵 树（即一个连通、无向、无环图），根节点是节点 0 ，这棵树由编号从 0 到 n - 1 的 n 个节点组成。用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树，其中 parent[i] 是节点 i 的父节点，由于节点 0 是根节点，所以 parent[0] == -1 。另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符。请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径 ，并返回该路径的长度。

```java
class Solution {
    private List<Integer>[] g;
    private char[] s;
    private int ans;

    public int longestPath(int[] parent, String s) {
        this.s = s.toCharArray();
        int n = parent.length;
        g = new ArrayList[n];
        Arrays.setAll(g, e -> new ArrayList<>());
        for (int i = 1; i < n; i++) {
            g[parent[i]].add(i);//g[i]存储第i个结点邻居
        }
        dfs(0);
        return ans + 1;//节点数 = 边数（直径） + 1
    }

    int dfs(int x){
        int maxLen = 0;
        for(int y : g[x]){
            int y_len = dfs(y) + 1;
            if(s[x] != s[y]){
                ans = Math.max(ans, maxLen + y_len);
                maxLen = Math.max(maxLen, y_len);
            }
        }
        return maxLen;
    }
}
```
### 例题：
#### 例题一：力扣337.打家劫舍
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。
```java
//暴力求解
public int rob(TreeNode root) {
    if (root == null) return 0;

    int money = root.val;
    if (root.left != null) {
        money += (rob(root.left.left) + rob(root.left.right));
    }

    if (root.right != null) {
        money += (rob(root.right.left) + rob(root.right.right));
    }

    return Math.max(money, rob(root.left) + rob(root.right));
}
//2. 剪枝
class Solution {
    HashMap<TreeNode, Integer> memo = new HashMap<>();
    public int rob(TreeNode root) {
        if(root == null) return 0;
        if(memo.containsKey(root)) return memo.get(root);
        int money = root.val;
        if(root.left != null) {
            money += (rob(root.left.left) + rob(root.left.right));
        }
        if(root.right != null) {
            money += (rob(root.right.left) + rob(root.right.right));
        }
        memo.put(root,Math.max(money, rob(root.left) + rob(root.right)));
        return memo.get(root);
    }
}

//3. 选或不选（偷或不偷）
class Solution {
    public int rob(TreeNode root) {
        int[] res = dfs(root);//res[0]：选  res[1]：不选
        return Math.max(res[0], res[1]); // 根节点选或不选的最大值
    }

    private int[] dfs(TreeNode node) {
        if (node == null) { // 递归边界
            return new int[]{0, 0}; // 没有节点，怎么选都是 0
        }
        int[] left = dfs(node.left); // 递归左子树
        int[] right = dfs(node.right); // 递归右子树
        int rob = left[1] + right[1] + node.val; // 选
        int notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // 不选
        return new int[]{rob, notRob};
    }
}
```
#### 例题二：力扣968.监控二叉树
