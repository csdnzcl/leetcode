# 动态规划
## 树形DP
### 树的直径
概念：树中任意两个节点之间最长路径的长度
补充：树的节点数 = 总边数 + 1
#### 二叉树
**二叉树的直径**：从一个叶子出发并向上，在某个节点**拐弯**，向下到达另一个叶子----得到由两条**链**拼起来的路径（也可能只有一条链）
**算法**：
+ 遍历二叉树，在计算最长链的同时，顺带计算直径
    + 在当前节点**拐弯**的直径长度 = 左子树最长链 + 右子树最长链 + 2.
    + 返回给父节点的是以**当前节点为根的子树的最长链**：max(左子树max, 右子树max) + 1;

1. **例题一**：力扣543.二叉树的直径
**题目描述**：给你一棵二叉树的根节点，返回该树的 直径 。二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。两节点之间路径的 长度 由它们之间边数表示。
```java
class Solution {
    int max = -1;
    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return max;
    }

    int dfs(TreeNode root) {
        if(root == null) return -1;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int cur = left + right + 2;
        max = Math.max(max, cur);
        return Math.max(left, right) + 1;
    }
}
```
2. **例题二**：力扣124.二叉树中的最大路径和
**题目描述**：二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和。
```java
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        max = root.val;
        dfs(root);
        return max;
    }

    int dfs(TreeNode root) {
        if(root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int cur = left + right + root.val;
        max = Math.max(cur, max);
        return Math.max(0, Math.max(left, right) + root.val);
    }
}
```
#### 一般树
邻居：相连的节点
**如何求树的直径？**
+ 思路一：遍历x的子树，把子树最长链的长度都存到一个列表中，排序，取最大的两个

+ 思路二：遍历x的子树的同时求最长 + 次长
链式前向心？？？？

**例题**：力扣2246.相邻字符不同的最长路径
**题目描述**：
给你一棵 树（即一个连通、无向、无环图），根节点是节点 0 ，这棵树由编号从 0 到 n - 1 的 n 个节点组成。用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树，其中 parent[i] 是节点 i 的父节点，由于节点 0 是根节点，所以 parent[0] == -1 。另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符。请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径 ，并返回该路径的长度。

```java
class Solution {
    private List<Integer>[] g;
    private char[] s;
    private int ans;

    public int longestPath(int[] parent, String s) {
        this.s = s.toCharArray();
        int n = parent.length;
        g = new ArrayList[n];
        Arrays.setAll(g, e -> new ArrayList<>());
        for (int i = 1; i < n; i++) {
            g[parent[i]].add(i);//g[i]存储第i个结点邻居
        }
        dfs(0);
        return ans + 1;//节点数 = 边数（直径） + 1
    }

    int dfs(int x){
        int maxLen = 0;
        for(int y : g[x]){
            int y_len = dfs(y) + 1;
            if(s[x] != s[y]){
                ans = Math.max(ans, maxLen + y_len);
                maxLen = Math.max(maxLen, y_len);
            }
        }
        return maxLen;
    }
}
```