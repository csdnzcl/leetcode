# 动态规划
## 状态机动态规划 (State Machine DP)

### 1. 核心概念：为什么要引入“状态机”？
在线性 DP 中，我们的状态通常只需要一个变量 $i$（代表走到第几个位置）。
但在很多复杂问题中，仅仅知道“当前在第几天”或“第几个位置”是不够的，我们还需要知道**当前的身份或状态**。

**对比视角：**
* **线性 DP：** `dp[i]`
    * 含义：第 $i$ 天的最优解。
    * 比如：爬楼梯到第 $i$ 层的方法数。
* **状态机 DP：** `dp[i][state]`
    * 含义：第 $i$ 天，且处于 `state` 状态下的最优解。
    * 比如：第 $i$ 天，手里**持有股票**时的最大利润。

**核心特征：**
1.  **二维数组：** 第一维 $N$ (时间/序列)，第二维 $K$ (状态数，通常很小，如 0/1/2)。
2.  **状态流转：** 就像画流程图一样，状态之间通过“动作”（买入、卖出、休息）互相转换。

---

### 2. 入门模型：无限次股票交易
**题目：** LeetCode 122. 买卖股票的最佳时机 II

#### 2.1 状态定义
每一天结束时，我们必然处于以下两种状态之一：
* **状态 0 (空仓)：** 手里没有股票。
* **状态 1 (持仓)：** 手里持有股票。

定义 `dp[i][0]` 为第 $i$ 天结束时**空仓**的最大收益。
定义 `dp[i][1]` 为第 $i$ 天结束时**持仓**的最大收益。

#### 2.2 状态转移 (画图思维)
我们要思考：**“今天”的状态可以由“昨天”的什么状态演变而来？**

1.  **推导 `dp[i][0]` (今天空仓)：**
    * **来源 A：** 昨天就没票，今天休息。 $\rightarrow dp[i-1][0]$
    * **来源 B：** 昨天有票，今天**卖了**。 $\rightarrow dp[i-1][1] + prices[i]$
    * **方程：** $dp[i][0] = \max(dp[i-1][0], \quad dp[i-1][1] + prices[i])$

2.  **推导 `dp[i][1]` (今天持仓)：**
    * **来源 A：** 昨天就有票，今天休息。 $\rightarrow dp[i-1][1]$
    * **来源 B：** 昨天没票，今天**买了**。 $\rightarrow dp[i-1][0] - prices[i]$
    * **方程：** $dp[i][1] = \max(dp[i-1][1], \quad dp[i-1][0] - prices[i])$

#### 2.3 Java 代码模板
```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // dp[i][0]: 空仓, dp[i][1]: 持仓
        int[][] dp = new int[n][2];
        
        // Base Case (第 0 天)
        dp[0][0] = 0;          // 没买，利润 0
        dp[0][1] = -prices[0]; // 买了，利润为负
        
        for (int i = 1; i < n; i++) {
            // 套用转移方程
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        
        // 最后一天肯定是空仓赚得多（因为拿着股票没变现就是废纸）
        return dp[n-1][0];
    }
}
```
---

### 3. 进阶模型：含冷冻期 (Cooldown)
**题目：** LeetCode 309. 最佳买卖股票时机含冷冻期
**规则：** 卖出股票后，第二天无法买入股票（即冷冻期为 1 天）。

#### 3.1 状态扩充
因为多了“冷冻期”这个限制，简单的 0/1 状态不够用了。我们需要把“空仓”状态拆得更细：

* **状态 0 (持有)：** 手里有股票。
* **状态 1 (可买)：** 手里没股票，且**不在冷冻期**（可以随时买）。
* **状态 2 (冷冻)：** 手里没股票，但是**刚刚卖出**（处于冷冻期，明天才能买）。

#### 3.2 转移逻辑图
* **持有 (State 0) $\leftarrow$**
    * 昨天持有，今天休息 ($dp[i-1][0]$)
    * 昨天是“可买”状态，今天**买入** ($dp[i-1][1] - prices[i]$)
    * *(注意：不能从“冷冻”直接变“持有”，必须先解冻)*
* **可买 (State 1) $\leftarrow$**
    * 昨天就是“可买”，今天休息 ($dp[i-1][1]$)
    * 昨天是“冷冻”，今天**解冻**了 ($dp[i-1][2]$)
* **冷冻 (State 2) $\leftarrow$**
    * 昨天持有，今天**卖出** ($dp[i-1][0] + prices[i]$)
    * *(这是唯一能进入冷冻期的路径)*

#### 3.3 核心代码
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        int n = prices.length;
        int[][] dp = new int[n][3];

        // 初始化
        dp[0][0] = -prices[0]; // 持有
        dp[0][1] = 0;          // 可买
        dp[0][2] = 0;          // 冷冻 (第0天不可能处于冷冻，初始化为0即可)

        for (int i = 1; i < n; i++) {
            // 1. 持有： 昨天持有 OR 昨天可买+今天买入
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]);
            
            // 2. 可买： 昨天可买 OR 昨天冷冻+今天解冻
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2]);
            
            // 3. 冷冻： 昨天持有+今天卖出
            dp[i][2] = dp[i-1][0] + prices[i];
        }

        // 最后结果不可能是在“持有”状态，比较剩下两种
        return Math.max(dp[n-1][1], dp[n-1][2]);
    }
}
```
### 4. 进阶模型二：状态机 + 计数
**题目：** 188. 买卖股票的最佳时机 IV (限制交易次数 k，状态机 + 计数)
**规则：** 限制交易次数k，不能同时参与多笔交易（买进 卖出为一组）
回溯法 + 剪枝：
```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        int[][][] cache = new int[n][k + 1][2];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= k; ++j) {
                Arrays.fill(cache[i][j], -1);
            }
        }
        return dfs(n-1, k, 0, cache, prices);
    }

    int dfs(int i, int j, int state, int[][][] cache, int[] prices) {
        if(j < 0) return Integer.MIN_VALUE / 2;
        if(i < 0) return state == 0 ? 0 : Integer.MIN_VALUE / 2;
        if(cache[i][j][state] != -1) return cache[i][j][state];
        if(state == 0) {
            return cache[i][j][state] = Math.max(
                dfs(i - 1, j, 0, cache, prices), 
                dfs(i - 1, j - 1, 1, cache, prices) + prices[i]
            );
        }
        if(state == 1) {
            return cache[i][j][state] = Math.max(
                dfs(i - 1, j, 1, cache, prices), 
                dfs(i - 1, j, 0, cache, prices) - prices[i]
                );
        }
        return cache[i][j][state];
    }
}
```
状态机DP：
```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        int dp[][][] = new int[n + 1][k + 2][2];
        for (int[][] mat : dp) {
            for (int[] row : mat) {
                Arrays.fill(row, Integer.MIN_VALUE / 2); 
            }
        }
        for(int j = 1; j <= k + 1; ++j){
            dp[0][j][0] = 0;
        }
        for(int i = 0; i < n; ++i) {
            for(int j = 1; j <= k + 1; ++j) {
                    dp[i + 1][j][0] = Math.max(dp[i][j][0], dp[i][j][1] + prices[i]);
                    dp[i + 1][j][1] = Math.max(dp[i][j][1], dp[i][j - 1][0] - prices[i]);
            }
        }
        return dp[n][k + 1][0];
    }
}


//2. 空间优化：
class Solution {
    public int maxProfit(int k, int[] prices) {
        int[][] f = new int[k + 2][2];
        for (int j = 1; j <= k + 1; j++) {
            f[j][1] = Integer.MIN_VALUE / 2; // 防止溢出
        }
        f[0][0] = Integer.MIN_VALUE / 2;
        for (int p : prices) {
            for (int j = k + 1; j > 0; j--) {
                f[j][0] = Math.max(f[j][0], f[j][1] + p);
                f[j][1] = Math.max(f[j][1], f[j - 1][0] - p);
            }
        }
        return f[k + 1][0];
    }
}

```
#### 思考题
1. 恰好完成k笔交易
```java
import java.util.Arrays;

class Solution {
    public int maxProfitExactlyK(int k, int[] prices) {
        int n = prices.length;
        if (n == 0 || k == 0) return 0; // 边界情况
        
        // 如果 k 超过 n/2，等同于无限次交易（因为无法完成恰好 k 次，只能尽可能多）
        // 但严格来说，如果题目强制要求恰好 K 次且 K > n/2，应该返回不可能(比如 -1)
        // 这里假设 k 是合理的

        // dp[j][0]: 恰好完成 j 次交易，空仓
        // dp[j][1]: 正在进行第 j+1 次交易，持仓
        int[][] dp = new int[k + 1][2];

        // 1. 初始化：全部设为负无穷，表示“不可能”
        // 注意：不要用 Integer.MIN_VALUE，防止减去 prices[i] 后溢出
        for (int[] row : dp) Arrays.fill(row, -1000000000);

        // 2. Base Case：只有“0交易且空仓”是合法的初始状态
        dp[0][0] = 0; 
        dp[0][1] = -prices[0]; // 第一次买入也是合法的

        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= k; j++) {
                // 卖出：保持恰好 j 次
                dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i]);
                
                // 买入：从“恰好 j-1 次”变成“正在进行第 j 次”
                // 注意：如果 dp[j-1][0] 是负无穷（说明还没完成 j-1 次），这里也会是负无穷
                dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i]);
            }
        }

        // 3. 返回结果：必须恰好是 k 次，且最后是空仓
        // 如果结果是负数，说明无法完成 k 次交易
        return dp[k][0] < 0 ? 0 : dp[k][0];
    }
}
```

2. 至少完成k笔交易
```java
import java.util.Arrays;

class Solution {
    public int maxProfitAtLeastK(int k, int[] prices) {
        int n = prices.length;
        // 如果天数不够完成 K 次，直接返回 -1 或 0
        if (n < 2 * k) return -1; 

        // dp[j][0]: 完成 j 次交易，空仓
        // 当 j = k 时，代表 ">= k" 次
        int[][] dp = new int[k + 1][2];

        // 1. 初始化：强制必须经历之前的次数才能到达 k
        for (int[] row : dp) Arrays.fill(row, -1000000000);

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < n; i++) {
            // 先处理 j = 1 到 k-1 的正常逻辑
            for (int j = 1; j < k; j++) {
                dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i]);
                dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i]);
            }

            // 特殊处理 j = k (代表 >= k 次)
            // 卖出：可以是 "恰好k次持有" 卖出，也可以是 "已经>k次持有" 卖出
            dp[k][0] = Math.max(dp[k][0], dp[k][1] + prices[i]);
            
            // 买入：可以是 "恰好k-1次空仓" 买入（变成k），也可以是 "已经>k次空仓" 买入（保持k）
            // 注意：这里 dp[k][0] - prices[i] 代表在 >=k 的基础上再买，状态依然算作 >=k
            dp[k][1] = Math.max(dp[k][1], 
                                Math.max(dp[k - 1][0] - prices[i], dp[k][0] - prices[i]));
        }

        // 返回 >= k 状态下的最大值
        return dp[k][0] < 0 ? 0 : dp[k][0];
    }
}
```

### 5. 总结：状态机 DP 解题模板
只要遇到题目中有“状态切换”、“冷却时间”、“交易手续费”等字眼，按以下步骤操作：

1. 定义状态枚举： 把所有可能的“身份”列出来（0, 1, 2...）。

2. 画出状态转移图： 用箭头标出状态之间是如何跳转的，以及跳转的代价（加钱/减钱）。

3. 编写转移方程： 看着图写代码，每个箭头对应一个 Math.max 的分支。

4. 初始化 Base Case： 考虑第 0 天每个状态是否合法（不合法的设为负无穷 -Infinity，合法的设为初始值）。

#### 必刷题目清单：
+  122. 买卖股票的最佳时机 II (基础 0/1 状态)
+ 309. 最佳买卖股票时机含冷冻期 (3 种状态)
+ 714. 买卖股票的最佳时机含手续费 (在卖出时减去 fee 即可)
+ 188. 买卖股票的最佳时机 IV (限制交易次数 k，状态机 + 计数)
