# 动态规划
## 动态规划入门 从记忆化搜索到递推
- 记忆化搜索：自顶向下算
- 递推：自底向上算
关键点：**状态定义？状态转移方程**？
DP三步：
1. 思考回溯怎么写
- 入参和返回值
- 递归到哪里
- 递归边界和入口
2. 改成记忆化搜索
```java
public int rob(int[] nums) {
    int[] cache = new int[nums.length];
    Arrays.fill(cache, -1);
    return dfs(nums.length - 1, nums,cache);  
}

private int dfs(int i, int[] nums, int[] cache) {
    if(i < 0) {
        return 0;
    }
    if(cache[i] != -1){
        return cache[i];
    }
    int ans =  Math.max(dfs(i-1,nums,cache), dfs(i - 2, nums,cache) + nums[i]);
    cache[i] = ans;
    return ans;
}
```
3. 1:1翻译成递推
- dfs      -->f数组
- 递归      -->循环
- 递归边界  -->数组初始值
即：递归 + 记忆化数组 --->> **循环 + f数组**
```java
public int rob(int[] nums) {
    int n = nums.length;
    if(n == 1) return nums[0];
    int[] f = new int[n];
    Arrays.fill(f,0);
    f[0] = nums[0];
    f[1] = Math.max(f[0], nums[1]);
    for(int i = 2; i < n; ++i) {
        f[i] = Math.max(f[i-1], f[i-2] + nums[i]);
    }
    return f[n-1];
}
```
复杂度：状态个数 * 状态所需时间
## 0-1背包---选or不选
1. 定义：有n个物品，第i个物品的体积为w[i]，价值为v[i]  每个物品至多选一个，求体积和不超过capacity时的最大价值和  
2. 回溯三问：
**当前操作？**  
枚举第i个物品选或不选：  
- 不选，剩余容量不变；  
- 选，剩余容量减少w[i]  

**子问题？**  
在剩余容量为c时，从前i个物品中得到的最大价值和  

**下一个子问题？** 分类讨论：  
- 不选：在剩余容量为c时，从前i-1个物品中得到的最大价值和  
- 选：在剩余容量为c - w[i]时，从前i-1个物品中得到的最大价值和  

**状态转移方程**：  
`dfs(i, c) = max(dfs(i - 1, c), dfs(i - 1, c - w[i]) + v[i])`
例题：
给你一个非负整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

代码：
```java
//1. 记忆化搜索
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        int sum = 0;
        for(int i = 0; i < n; ++i) {
            sum += nums[i];
        }
        sum -= Math.abs(target);
        if(sum < 0 || sum % 2 == 1) {
            return 0;
        }
        sum /= 2;
//cache[i][c] != -1,则dfs(i,c) = cache[i][c]:dfs(i, c):只使用数组中下标为 0 到 i 的这些物品，
// 把容量 c 填满，有多少种方法？
        int[][] cache = new int[n][sum + 1];
        for(int[] row : cache) {
            Arrays.fill(row, -1);
        }
        return dfs(n - 1, sum, nums, cache);
    }

    private int dfs(int i, int c, int[] nums, int[][] cache) {
        if(i < 0) {
            return c == 0 ? 1 : 0;
        }
        if(cache[i][c] != -1) {
            return cache[i][c];
        }
        int ans = dfs(i - 1, c, nums, cache);//不选第i个数
        if(c >= nums[i]) {
            ans += dfs(i - 1, c - nums[i], nums, cache);//选第i个数
        }
        return cache[i][c] = ans;
    }
}

//2. 递推
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        int sum = 0;
        for(int i = 0; i < n; ++i) {
            sum += nums[i];
        }
        sum -= Math.abs(target);
        if(sum < 0 || sum % 2 == 1) {
            return 0;
        }
        int m = sum / 2;
        int dp[][] = new int[n + 1][m + 1];
//dp[i][j] 定义：从前 i 个物品中选，凑出容量 j 的方法数
        for(int[] a : dp){
            Arrays.fill(a, 0);
        }
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1]; 
            for (int j = 0; j <= m; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[n][m];
    }
}

//3. 空间优化：使用一维数组---因为dp[i][……]之和dp[i-1][……]相关
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int x : nums) sum += x;
        sum -= Math.abs(target);
        if (sum < 0 || sum % 2 == 1) return 0;
        int m = sum / 2;
        // dp[j] 定义：凑满容量 j 有多少种方法
        int[] dp = new int[m + 1];
        dp[0] = 1;
//注意遍历方向：
        for (int num : nums) {
            for (int j = m; j >= num; j--) {
                dp[j] = dp[j] + dp[j - num];
            }
        }
        return dp[m];
    }
}
```
## 完全背包---选or不选
1. 定义：有n种物品，第i种物品的体积为w[i],价值为v[i],每种物品无限次重复选，求体积和不超过capacity时的最大价值和
**回溯三问** 
1. **当前操作？**  
枚举第i种物品选一个或不选：  
- 不选，剩余容量不变；  
- 选一个，剩余容量减少 w[i]  
2. **子问题？**  
在剩余容量为 c 时，从前i种物品中得到的最大价值和  
3. **下一个子问题？** 分类讨论：  
- 不选：在剩余容量为 c 时，从前i-1种物品中得到的最大价值和  
- 选一个：在剩余容量为 c - w[i] 时，从前i种物品中得到的最大价值和  

**状态转移方程**：  
`dfs(i, c) = max(dfs(i - 1, c), dfs(i, c - w[i]) + v[i])`

```java
//1. 记忆化搜索
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] cache = new int[n][amount + 1];
        for (int[] row : cache) {
            Arrays.fill(row, -1); // -1 表示没有计算过
        }

        int ans = dfs(n - 1, amount, coins, cache);
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }

    private int dfs(int i, int c, int[] coins, int[][] cache) {
        if (i < 0) {
            return c == 0 ? 0 : Integer.MAX_VALUE / 2; // 除 2 防止下面 + 1 溢出
        }
        if (cache[i][c] != -1) { // 之前计算过
            return cache[i][c];
        }
        if (c < coins[i]) { // 只能不选
            return cache[i][c] = dfs(i - 1, c, coins, cache);
        }
        // 不选 vs 继续选
        return cache[i][c] = Math.min(dfs(i - 1, c, coins, cache), dfs(i, c - coins[i], coins, cache) + 1);
    }
}

//2. 翻译成递推
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        Arrays.fill(f[0], Integer.MAX_VALUE / 2); // 除 2 防止下面 + 1 溢出
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int c = 0; c <= amount; c++) {
                if (c < coins[i]) {
                    dp[i + 1][c] = dp[i][c];
                } else {
                    dp[i + 1][c] = Math.min(dp[i][c], dp[i + 1][c - coins[i]] + 1);
                }
            }
        }
        int ans = dp[n][amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
}

//3. 空间优化：两个数组（滚动数组）
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] dp = new int[2][amount + 1];
        Arrays.fill(dp[0], Integer.MAX_VALUE / 2);
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int c = 0; c <= amount; c++) {
                if (c < coins[i]) {
                    dp[(i + 1) % 2][c] = dp[i % 2][c];
                } else {
                    dp[(i + 1) % 2][c] = Math.min(dp[i % 2][c], dp[(i + 1) % 2][c - coins[i]] + 1);
                }
            }
        }
        int ans = dp[n % 2][amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
}

//4. 空间优化：一个数组
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE / 2);
        dp[0] = 0;
        for (int x : coins) {
            for (int c = x; c <= amount; c++) {
                dp[c] = Math.min(dp[c], dp[c - x] + 1);
            }
        }
        int ans = dp[amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
}
```
## 常见变形
- 至多装 capacity：求方案数 / 最大价值和
- 恰好装 capacity：求方案数 / 最大 / 最小价值和
- 至少装 capacity：求方案数 / 最小价值和