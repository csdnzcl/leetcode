# 动态规划
## 线性DP
### 1. 核心概念
线性 DP 是动态规划中最基础的形式。它的核心特征是**状态的推导是线性的**，即求解第 $i$ 个状态时，主要依赖于前几个状态（如 $i-1, i-2, \dots$）。

**解题四部曲：**
1.  **定义状态 ($dp$ 数组含义)：** 这一步错了，后面全错。
2.  **寻找转移方程：** 也就是找规律，如何用已知的小问题算出当前的大问题。
3.  **初始化 (Base Case)：** 处理边界，防止数组越界（如 $dp[0]$）。
4.  **确定遍历顺序：** 通常是从小到大遍历（$i$ 从 0 到 $n$）。

---

### 2. 模型一：决策型 (选或不选)
这类问题的特点是：在处理第 $i$ 个元素时，需要根据限制条件决定“选它”还是“不选它”。

#### 例题：打家劫舍 (LeetCode 198)
> **题目描述：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。求今晚能够偷窃到的最高金额。

**思路分析：**
* **状态定义：** $dp[i]$ 表示从下标 $0$ 到 $i$ 的房子中能偷到的最大金额。
* **决策过程：** 对于第 $i$ 间房：
    1.  **偷：** 那么第 $i-1$ 间肯定不能偷，收益是 `前 i-2 间的最大值` + `第 i 间的钱`。 即 $dp[i-2] + nums[i]$。
    2.  **不偷：** 那么收益就是 `0 ~ i-1 间的最大值`。 即 $dp[i-1]$。
* **转移方程：**
    $$dp[i] = \max(dp[i-1], \quad dp[i-2] + nums[i])$$

**Java 代码实现：**
```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int n = nums.length;
        if (n == 1) return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
        }
        return dp[n-1];
    }
}
```

---

### 3. 模型二：连续子数组型 (必须以 i 结尾)
这类问题的痛点在于：为了保证“连续性”，状态必须定义为“以 $i$ 结尾”。**最终结果往往不是 $dp[n-1]$，而是整个 $dp$ 数组中的最大值。**

#### 例题：最大子数组和 (LeetCode 53)
> **题目描述：** 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**思路分析：**
* **状态定义：** $dp[i]$ 表示**必须以 `nums[i]` 结尾**的连续子数组的最大和。
* **决策过程：** 站在 $i$ 的位置看 $i-1$：
    1.  如果 $dp[i-1] > 0$：那我们就接上前面的队伍，因为能让总和变大。
    2.  如果 $dp[i-1] < 0$：前面的和是负的或零，那是拖油瓶，不如我自己另起炉灶。
* **转移方程：**
    $$dp[i] = \max(nums[i], \quad dp[i-1] + nums[i])$$

**Java 代码实现：**
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int maxAns = dp[0]; 
        for (int i = 1; i < n; i++) {
            if (dp[i-1] > 0) {
                dp[i] = dp[i-1] + nums[i];
            } else {
                dp[i] = nums[i];
            }
            // 实时更新全局最大值
            maxAns = Math.max(maxAns, dp[i]);
        }
        return maxAns;
    }
}
```

---

### 4. 模型三：子序列型 (非连续依赖)
这类问题通常涉及 $O(n^2)$ 的复杂度，因为计算 $dp[i]$ 时，不仅仅看 $dp[i-1]$，还要回头看 $0$ 到 $i-1$ 的所有状态。

#### 例题：最长递增子序列 (LIS) (LeetCode 300)
> **题目描述：** 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。（子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序）。

**思路分析：**
* **状态定义：** $dp[i]$ 表示以 `nums[i]` **结尾**的最长递增子序列的长度。
* **决策过程：** 想要算出 $dp[i]$，我们需要遍历 $j$ ($0 < j < i$)：
    * 只要 $nums[i] > nums[j]$，说明 `nums[i]` 可以接在 `nums[j]` 后面形成一个更长的序列。
    * 我们要找所有满足条件的 $j$ 中，能让 $dp[i]$ 变最大的那个。
* **转移方程：**
    $$dp[i] = \max(dp[j]) + 1 \quad \text{其中 } 0 < j < i \text{ 且 } nums[i] > nums[j]$$

**Java 代码实现：**
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        
        // 初始化：每个元素自身至少是一个长度为 1 的子序列
        Arrays.fill(dp, 1);
        
        int maxAns = 1;
        
        for (int i = 1; i < nums.length; i++) {
            // 内层循环：回头看之前所有的元素
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    // 尝试接在 nums[j] 后面
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxAns = Math.max(maxAns, dp[i]);
        }
        
        return maxAns;
    }
}
```

---

### 5. 进阶模型：二维双串 DP (Dual-String DP)
这是线性 DP 的二维形态，通常用于解决**两个字符串**或**两个数组**之间的匹配、比较或转换问题。

* **核心特征：** 输入是两个序列（如 String A 和 String B）。
* **状态定义：** 必须使用二维数组 $dp[i][j]$。
    * $i$ 代表第一个序列处理到了第 $i$ 个元素。
    * $j$ 代表第二个序列处理到了第 $j$ 个元素。
    * $dp[i][j]$ 代表“A 的前 $i$ 个”和“B 的前 $j$ 个”之间的最优解。
* **决策视角：** 填写二维表格。计算 $dp[i][j]$ 时，通常参考左边 ($i, j-1$)、上边 ($i-1, j$) 和左上角 ($i-1, j-1$) 的值。


#### 例题：最长公共子序列 (LeetCode 1143)
> **题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不包含，返回 0。

**思路分析：**
* **状态定义：** $dp[i][j]$ 表示 `text1` 的前 $i$ 个字符与 `text2` 的前 $j$ 个字符的最长公共子序列长度。
* **决策过程：** 比较 `text1[i-1]` 和 `text2[j-1]`（注意：DP 下标从 1 开始，字符串下标从 0 开始）：
    1.  **相等：** 既然字符一样，那这个字符一定在公共子序列里。长度 = `去掉这两个字符剩下的最长长度` + 1。
        * 即：$dp[i-1][j-1] + 1$
    2.  **不相等：** 既然不一样，那就尝试扔掉 `text1` 的尾巴，或者扔掉 `text2` 的尾巴，看谁剩下的公共部分更长。
        * 即：$\max(dp[i-1][j], \quad dp[i][j-1])$
* **转移方程：**
    $$
    dp[i][j] = \begin{cases} 
    dp[i-1][j-1] + 1, & \text{if } text1[i-1] == text2[j-1] \\
    \max(dp[i-1][j], dp[i][j-1]), & \text{if } text1[i-1] \neq text2[j-1]
    \end{cases}
    $$

**Java 代码实现：**
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        
        // 技巧：多开一行一列，用于处理空字符串的情况（Base Case 全为0）
        // dp[0][j] 和 dp[i][0] 均为 0，代表其中一个是空串，公共子序列长度自然为 0
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                
                if (c1 == c2) {
                    // 找到了公共字符，来自左上角
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 没找到，继承左边或上边的最大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}

```
---

### 6. 补遗模型：网格图 DP (Grid DP)
这类题目是“爬楼梯”问题的二维升级版。通常场景是机器人在一个 $m \times n$ 的网格中，从左上角走到右下角，且只能**向右**或**向下**移动。

* **核心逻辑：** 既然只能从左边或上边过来，那么到达位置 $(i, j)$ 的状态，一定是由 $(i-1, j)$ 和 $(i, j-1)$ 推导出来的。

#### 例题：不同路径 (LeetCode 62)
> **题目描述：** 一个机器人位于一个 $m \times n$ 网格的左上角。机器人每次只能向下或者向右移动一步。问总共有多少条不同的路径能到达右下角？

**思路分析：**
* **状态定义：** $dp[i][j]$ 表示从起点 $(0,0)$ 走到 $(i, j)$ 的路径总数。
* **决策过程：**
    * 想要走到 $(i, j)$，最后一步只能是从上面 $(i-1, j)$ 下来，或者从左面 $(i, j-1)$ 过来。
    * 所以，路径数 = 上面的路径数 + 左边的路径数。
* **转移方程：**
    $$dp[i][j] = dp[i-1][j] + dp[i][j-1]$$
* **初始化：**
    * 第一行 ($i=0$)：只能一直向右走，所以所有 $dp[0][j] = 1$。
    * 第一列 ($j=0$)：只能一直向下走，所以所有 $dp[i][0] = 1$。

**Java 代码实现：**
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        
        // 初始化
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        
        // 开始遍历（从非边界位置开始）
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        
        return dp[m-1][n-1];
    }
}
```

---

### 7. 总结：线性 DP 的两大核心视角

做线性 DP 题目时，最容易卡壳的地方往往是 **状态定义 ($dp[i]$ 到底代表什么)**。
根据 $dp[i]$ 的定义方式，我们可以将大多数线性 DP 分为两类。解题前，先判断属于哪一类，能避免走很多弯路。

| 视角类型 | 典型定义 ($dp[i]$) | 结果取值 (Answer) | 核心特征 | 典型例题 |
| :--- | :--- | :--- | :--- | :--- |
| **前缀型** | **前 $i$ 个元素**的最优解 <br> *(注意：第 $i$ 个元素不一定被选中)* | **直接返回 $dp[n-1]$** <br> *(因为最后一个状态涵盖了全局最优)* | 步步为营，后面的状态包含前面的结果 | • 爬楼梯 (LC 70)<br>• 打家劫舍 (LC 198)<br>• 股票买卖 |
| **结尾型** | 必须**以第 $i$ 个元素结尾**的最优解 <br> *(注意：第 $i$ 个元素必须包含在解中)* | **返回 $\max(dp \text{数组})$** <br> *(必须遍历整个 dp 数组找最大值)* | 强行绑定，为了保证子序列/子数组的连续性或特定顺序 | • 最大子数组和 (LC 53)<br>• 最长递增子序列 LIS (LC 300) |

---

