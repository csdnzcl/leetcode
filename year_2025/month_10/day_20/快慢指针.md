\# 快慢指针（Floyd 判圈算法）笔记



\&gt; 快慢指针（Floyd's Cycle-Finding Algorithm / Tortoise-and-Hare）  

\&gt; 一种“\*\*用 O(1) 额外空间\*\*”解决\*\*链表成环/找中点/找环入口\*\*等问题的经典技巧。



---



\## 1. 核心思想



维护两个指针：

\- \*\*慢指针\*\* `slow`：每次走 1 步  

\- \*\*快指针\*\* `fast`：每次走 2 步  



若链表\*\*无环\*\*，`fast` 会先到达尾部；  

若链表\*\*有环\*\*，`fast` 会“套圈”与 `slow` 相遇。



---



\## 2. 模板代码（java）



```java

// 快慢指针（Floyd 判圈算法）Java 模板

// 适用于：判断链表是否有环、找环入口、找中点等场景



public class FloydTemplate {



&nbsp;   /\* ===== 基础节点定义 ===== \*/

&nbsp;   static class ListNode {

&nbsp;       int val;

&nbsp;       ListNode next;

&nbsp;       ListNode(int val) { this.val = val; }

&nbsp;   }



&nbsp;   /\* 1. 判断是否有环 \*/

&nbsp;   public static boolean hasCycle(ListNode head) {

&nbsp;       if (head == null) return false;

&nbsp;       ListNode slow = head;

&nbsp;       ListNode fast = head;

&nbsp;       while (fast != null \&\& fast.next != null) {

&nbsp;           slow = slow.next;           // 1 步

&nbsp;           fast = fast.next.next;      // 2 步

&nbsp;           if (slow == fast) return true; // 相遇

&nbsp;       }

&nbsp;       return false;

&nbsp;   }



&nbsp;   /\* 2. 若有环，返回环入口；无环返回 null \*/

&nbsp;   public static ListNode detectCycle(ListNode head) {

&nbsp;       if (head == null) return null;

&nbsp;       ListNode slow = head;

&nbsp;       ListNode fast = head;

&nbsp;       // 阶段 1：找第一次相遇点

&nbsp;       while (fast != null \&\& fast.next != null) {

&nbsp;           slow = slow.next;

&nbsp;           fast = fast.next.next;

&nbsp;           if (slow == fast) break;

&nbsp;       }

&nbsp;       // 无环

&nbsp;       if (fast == null || fast.next == null) return null;

&nbsp;       // 阶段 2：slow 回 head，同步走 1 步/次

&nbsp;       slow = head;

&nbsp;       while (slow != fast) {

&nbsp;           slow = slow.next;

&nbsp;           fast = fast.next;

&nbsp;       }

&nbsp;       return slow; // 环入口

&nbsp;   }



&nbsp;   /\* 3. 找链表中点（偶数时返回右半第一个）\*/

&nbsp;   public static ListNode middleNode(ListNode head) {

&nbsp;       if (head == null) return null;

&nbsp;       ListNode slow = head;

&nbsp;       ListNode fast = head;

&nbsp;       while (fast != null \&\& fast.next != null) {

&nbsp;           slow = slow.next;

&nbsp;           fast = fast.next.next;

&nbsp;       }

&nbsp;       return slow; // 中点

&nbsp;   }



&nbsp;   /\* ===== 简单测试 ===== \*/

&nbsp;   public static void main(String\[] args) {

&nbsp;       // 构造带环链表 1->2->3->4->5->3（成环）

&nbsp;       ListNode n1 = new ListNode(1);

&nbsp;       ListNode n2 = new ListNode(2);

&nbsp;       ListNode n3 = new ListNode(3);

&nbsp;       ListNode n4 = new ListNode(4);

&nbsp;       ListNode n5 = new ListNode(5);

&nbsp;       n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; n5.next = n3;



&nbsp;       System.out.println("Has cycle? " + hasCycle(n1));        // true

&nbsp;       System.out.println("Cycle entry val: " + detectCycle(n1).val); // 3

&nbsp;   }

}

